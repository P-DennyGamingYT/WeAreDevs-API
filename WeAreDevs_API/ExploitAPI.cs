using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace WeAreDevs_API
{
    public class ExploitAPI
    {
        private WebClient client = new WebClient();
        private ExploitAPI.BasicInject injector = new ExploitAPI.BasicInject();
        private string cmdpipe = "WeAreDevsPublicAPI_CMD";
        private string luacpipe = "WeAreDevsPublicAPI_LuaC";

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool WaitNamedPipe(string name, int timeout);

        private static bool NamedPipeExist(string pipeName)
        {
            try
            {
                int timeout = 0;
                if (!ExploitAPI.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\\\\\.\\\\pipe\\\\{0}", (object)pipeName)), timeout))
                {
                    switch (Marshal.GetLastWin32Error())
                    {
                        case 0:
                            return false;
                        case 2:
                            return false;
                    }
                }
                return true;
            }
            catch (Exception ex)
            {
                return false;
            }
        }

        private void SMTP(string pipe, string input)
        {
            if (ExploitAPI.NamedPipeExist(pipe))
            {
                try
                {
                    using (NamedPipeClientStream pipeClientStream = new NamedPipeClientStream(".", pipe, PipeDirection.Out))
                    {
                        pipeClientStream.Connect();
                        using (StreamWriter streamWriter = new StreamWriter((Stream)pipeClientStream))
                        {
                            streamWriter.Write(input);
                            streamWriter.Dispose();
                        }
                        pipeClientStream.Dispose();
                    }
                }
                catch (IOException ex)
                {
                    int num = (int)MessageBox.Show("Error occured sending message to the game!", "Connection Failed!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                }
                catch (Exception ex)
                {
                    int num = (int)MessageBox.Show(ex.Message.ToString());
                }
            }
            else
            {
                int num1 = (int)MessageBox.Show("Error occured. Did the dll properly inject?", "Oops", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }

        private string ReadURL(string url)
        {
            return this.client.DownloadString(url);
        }

        public bool IsUpdated()
        {
            bool flag = false;
            string str = this.ReadURL("https://github.com/P-DennyGamingYT/WeAreDevs-API/raw/main/exploit-main.dll");
            if (str.Length > 0)
            {
                flag = Convert.ToBoolean(str.Split(' ')[0]);
            }
            else
            {
                int num = (int)MessageBox.Show("Could not check for the latest version. Did your fireall block us?", "Error");
            }
            return flag;
        }

        private bool DownloadLatestVersion()
        {
            if (System.IO.File.Exists("exploit-main.dll"))
                System.IO.File.Delete("exploit-main.dll");
            string str = this.ReadURL("https://github.com/P-DennyGamingYT/WeAreDevs-API/raw/main/exploit-main.dll");
            if (str.Length > 0)
                this.client.DownloadFile(str.Split(' ')[1], "exploit-main.dll");
            return System.IO.File.Exists("exploit-main.dll");
        }

        public bool LaunchExploit()
        {
            if (ExploitAPI.NamedPipeExist(this.cmdpipe))
            {
                int num1 = (int)MessageBox.Show("Dll already injected", "No problems");
            }
            else if (this.IsUpdated())
            {
                if (this.DownloadLatestVersion())
                {
                    if (this.injector.InjectDLL())
                        return true;
                    int num2 = (int)MessageBox.Show("DLL failed to inject", "Error");
                }
                else
                {
                    int num3 = (int)MessageBox.Show("Could not download the latest version! Did your firewall block us?", "Error");
                }
            }
            else
            {
                int num4 = (int)MessageBox.Show("Exploit currently patched. Try again tomorrow!", "Error");
            }
            return false;
        }

        internal void SendCommand(string Command)
        {
            this.SMTP(this.cmdpipe, Command);
        }

        public void SendScript(string Script)
        {
            foreach (string input in Script.Split("\r\n".ToCharArray()))
            {
                try
                {
                    this.SMTP(this.luacpipe, input);
                }
                catch (Exception ex)
                {
                    int num = (int)MessageBox.Show(ex.Message.ToString());
                }
            }
        }

        public void DoKill(string username = "me")
        {
            this.SendCommand("kill " + username);
        }

        public void CreateForceField(string username = "me")
        {
            this.SendCommand("ff " + username);
        }

        public void RemoveForceField(string username = "me")
        {
            this.SendCommand("noff " + username);
        }

        public void DoFloat(string username = "me")
        {
            this.SendCommand("float " + username);
        }

        public void DoNoFloat(string username = "me")
        {
            this.SendCommand("nofloat " + username);
        }

        public void RemoveLimbs(string username = "me")
        {
            this.SendCommand("nolimbs " + username);
        }

        public void RemoveArms(string username = "me")
        {
            this.SendCommand("noarms " + username);
        }

        public void RemoveLegs(string username = "me")
        {
            this.SendCommand("nolegs " + username);
        }

        public void AddFire(string username = "me")
        {
            this.SendCommand("fire " + username);
        }

        public void RemoveFire(string username = "me")
        {
            this.SendCommand("nofire " + username);
        }

        public void AddSparkles(string username = "me")
        {
            this.SendCommand("sparkles " + username);
        }

        public void RemoveSparkles(string username = "me")
        {
            this.SendCommand("nosparkles " + username);
        }

        public void AddSmoke(string username = "me")
        {
            this.SendCommand("smoke " + username);
        }

        public void DoBlockHead(string username = "me")
        {
            this.SendCommand("blockhead " + username);
        }

        public void ForceBubbleChat(string username = "me")
        {
            this.SendCommand("chat " + username);
        }

        public void ConsolePrint(string username = "me")
        {
            this.SendCommand("print " + username);
        }

        public void ConsoleWarn(string username = "me")
        {
            this.SendCommand("warn " + username);
        }

        private class BasicInject
        {
            [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
            internal static extern IntPtr LoadLibraryA(string lpFileName);

            [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
            internal static extern UIntPtr GetProcAddress(IntPtr hModule, string procName);

            [DllImport("kernel32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool FreeLibrary(IntPtr hModule);

            [DllImport("kernel32.dll")]
            internal static extern IntPtr OpenProcess(ExploitAPI.BasicInject.ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);

            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

            [DllImport("kernel32.dll")]
            internal static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, UIntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);

            public bool InjectDLL()
            {
                if (Process.GetProcessesByName("RobloxPlayerBeta").Length == 0)
                    return false;
                Process process = Process.GetProcessesByName("RobloxPlayerBeta")[0];
                byte[] bytes = new ASCIIEncoding().GetBytes(AppDomain.CurrentDomain.BaseDirectory + "exploit-main.dll");
                IntPtr hModule = ExploitAPI.BasicInject.LoadLibraryA("kernel32.dll");
                UIntPtr procAddress = ExploitAPI.BasicInject.GetProcAddress(hModule, "LoadLibraryA");
                ExploitAPI.BasicInject.FreeLibrary(hModule);
                if (procAddress == UIntPtr.Zero)
                    return false;
                IntPtr hProcess = ExploitAPI.BasicInject.OpenProcess(ExploitAPI.BasicInject.ProcessAccess.AllAccess, false, process.Id);
                if (hProcess == IntPtr.Zero)
                    return false;
                IntPtr num = ExploitAPI.BasicInject.VirtualAllocEx(hProcess, (IntPtr)0, (uint)bytes.Length, 12288U, 4U);
                UIntPtr lpNumberOfBytesWritten;
                IntPtr lpThreadId;
                return !(num == IntPtr.Zero) && ExploitAPI.BasicInject.WriteProcessMemory(hProcess, num, bytes, (uint)bytes.Length, out lpNumberOfBytesWritten) && !(ExploitAPI.BasicInject.CreateRemoteThread(hProcess, (IntPtr)0, 0U, procAddress, num, 0U, out lpThreadId) == IntPtr.Zero);
            }

            [Flags]
            public enum ProcessAccess
            {
                AllAccess = 1050235, // 0x0010067B
                CreateThread = 2,
                DuplicateHandle = 64, // 0x00000040
                QueryInformation = 1024, // 0x00000400
                SetInformation = 512, // 0x00000200
                Terminate = 1,
                VMOperation = 8,
                VMRead = 16, // 0x00000010
                VMWrite = 32, // 0x00000020
                Synchronize = 1048576, // 0x00100000
            }
        }
    }
}